compile yes.cpp with:
x86_64-w64-mingw32-g++ yes.cpp -fconcepts-ts -static -lgdi32 -Ofast -o yes

in calculating whether the line hits the sphere:
if(square(dot_product(ux, uy, uz, circle_x, circle_y, circle_z)) - circle_x * circle_x - circle_y * circle_y - circle_z * circle_z + radius * radius < 0) framebuf[j * width + i] = RGB(255, 0, 0);
else framebuf[j * width + i] = RGB(0, 0, 255);

stuff:
point c1(-150, 100, 2000), c2(150, 100, 2000), c3(150, -100, 2000);
vector a = c2 - c1, b = c3 - c1, c = cross_product(a, b);
ax + by + cz = k
double k = c.x * a.x + c.y * a.y + c.z * a.z;

earlier testing:
double x = ux * t;
double y = uy * t;
double z = uz * t;
std::cout << "hello " << x << '\n';
if(x < -250 || x > 250) framebuf[j * width + i] = RGB(255, 0, 0);
else framebuf[j * width + i] = RGB(0, 0, 255);

to calculate whether a point is in a triangle:

auto sign = [&](point p1, point p2, point p3) -> double{
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
};
double d1 = sign(intersection, c1, c2),
       d2 = sign(intersection, c2, c3),
       d3 = sign(intersection, c3, c1);
bool neg = d1 < 0 || d2 < 0 || d3 < 0,
     pos = d1 > 0 || d2 > 0 || d3 > 0;
if(!(neg && pos)) framebuf[j * width + i] = RGB(0, 0, 255);
else framebuf[j * width + i] = RGB(255, 0, 0);
                *

auto point_in_triangle = [&](point p, point a, point b, point c) -> bool{
    if(c.y == a.y){
        point temp = c;
        c = b;
        b = temp;
    }
    double s1 = c.y - a.y,
           s2 = c.x - a.x,
           s3 = b.y - a.y,
           s4 = p.y - a.y;
    double w1 = (a.x * s1 + s4 * s2 - p.x * s1) / (s3 * s2 - (b.x - a.x) * s1),
           w2 = (s4 - w1 * s3) / s1;
    return w1 >= 0 && w2 >= 0 && (w1 + w2) <= 1;
};

in windowprocessmessages (i forgot what this is supposed to do):
case WM_GETMINMAXINFO:{
    LPMINMAXINFO e = (LPMINMAXINFO)l;
    //e->ptMinTrackSize.x = 7;
    //e->ptMinTrackSize.y = 30;

    //e->ptMinTrackSize.x = 17;
    //e->ptMinTrackSize.y = 40;
    break;
}

in render():
vector v(-width / 2.0 + i, height / 2.0 - j, z);

use x86_64-w64-mingw32-g++ for better performance
auto start = high_resolution_clock::now();

std::pair<bool, double> hit_s = (world[0])->hit(v);
bool hit_sphere = hit_s.first;
double distance_to_sphere = hit_s.second;

std::pair<bool, double> hit_p = (world[1])->hit(v);
bool hit_polygon = hit_p.first;
double distance_to_polygon = hit_p.second;

auto stop = high_resolution_clock::now();
duration<double, std::milli> time_double = stop - start;
if(time_double.count()) std::cout << "count: " << time_double.count() << '\n';
std::cout << "count: " << time_double.count() << '\n';
for multiple objects create a list of objects the ray hit
with either inheritance or std::any or smth
and find which of the distances is least

bool hit_nothing = true;
object* smallest = world[0];

for(int w = 1; w < world.size(); ++w){
    //if(comp(hit_nothing, v, world[i], smallest)) smallest = world[i];
    std::pair<bool, double> hit_a = world[w]->hit(v), hit_b = smallest->hit(v);
    //std::pair<bool, double> hit_a(0, 0), hit_b(0, 0);

    if(unlikely(hit_a.first)){
        hit_nothing = false;
        if(unlikely(hit_b.first)){
            if(hit_a.second < hit_b.second)
                smallest = world[w];
        }
        else smallest = world[w];
    }
    else hit_nothing = !hit_b.first;
}
if(likely(hit_nothing)) framebuf[j * width + i] = RGB(255, 0, 0);
else framebuf[j * width + i] = smallest->clr;

in main function (height of the window testing):
//int a = width + 2, b = height + 29;
//int a = width + 2, b = height + 25;
(its supposed to be: int a = width + 16, b = height + 39;)